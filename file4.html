<!DOCTYPE html>
<html>

<head>
    <script>
        //fixme: 1.number with last param false
        //2.tooltip for indexes (arrayindex and arrayindex2 fixes; 
        //select array should delete arrayindex?)
        //3.copy from json / select value
        //4.multiple addremove for the same array

        const debug = true, //do you want debug in browser console?
            version = "250821";
        document.title = "DataCreator (MIT license) " + version;
    </script>
    <meta charset="utf-8">
    <style>
        label {
            grid-column: 1 / 2;
        }

        input,
        button,
        select,
        span {
            grid-column: 2 / 3;
        }

        .full {
            grid-column: 1 / 3;
            display: grid;
            grid-template-columns: 1fr 1fr;
        }
    </style>
</head>

<body>
    <input type="file" id="file" accept=".json" name="file" />
    <a id="getOutput" download="output.json" onclick='return getOutputJson();' title='Click to get output file' href=''>Get JSON</a>
    <p><span id="info"></span>
    <div style="display: flex;">
        <span style="flex: 40%; display: grid; grid-template-columns: 1fr 1fr; max-width: 800px;">
            <span id="editor" class="full" style="display:block;"></span>
        </span>
        <pre style="flex: 60%; margin: 30px; max-width: 400px; overflow-x: auto;" id="json"></pre>
    </div>
    <script>
        var inputData, //JSON with editor
            outputData = {}, //generated JSON
            addArray, //something to processing in the end
            selectAddReplace, //replace strings for paths in generated JSON
            processing; //string for debug info showing what is processed

        //called after clicking 'Get JSON' - creating correct base64 URL
        function getOutputJson() {
            if (JSON.stringify(outputData, null, 2).length == 2) {
                alert("Empty output file. Nothing to get.");
                return false;
            } else {
                var yesno = true;
                const obj = document.getElementsByTagName("font");
                for (var i in obj) {
                    if (obj[i].color == "red" && yesno) {
                        if (!confirm("You still have errors. Continue?")) return false;
                        yesno = false;
                    }
                }
                document.getElementById("getOutput").setAttribute('href', 'data:;base64,' +
                    btoa(JSON.stringify(outputData, null, 2)));
                return true;
            }
        }

        function getOutputFile(pathInOutputData, isHex) {
            const obj = findOutputObject(pathInOutputData, false, false);
            if (obj.obj[obj.lastPathElement].length != 0) {
                if (isHex) {
                    var obj2 = new Uint8Array(obj.obj[obj.lastPathElement].length / 2);
                    obj2.setFromHex(obj.obj[obj.lastPathElement].toLowerCase());
                    document.getElementById(pathInOutputData + "_get")
                        .setAttribute('href', 'data:;base64,' + (new Uint8Array(obj2)).toBase64());
                } else {
                    document.getElementById(pathInOutputData + "_get")
                        .setAttribute('href', 'data:;base64,' + obj.obj[obj.lastPathElement]);
                }
                return true;
            } else {
                alert('Empty file content. Nothing to get.');
                return false;
            }
        }

        function loadFile(f, pathInOutputData, isHex) {
            const reader = new FileReader();
            reader.onload = function(e2) {
                var obj = findOutputObject(pathInOutputData, false, false);
                obj.obj[obj.lastPathElement] = isHex ?
                    (new Uint8Array(e2.target.result)).toHex().toUpperCase() :
                    (new Uint8Array(e2.target.result)).toBase64();
                showFormattedOutputJson();
                document.getElementById(pathInOutputData + "_get")
                    .setAttribute('download', document.getElementById(pathInOutputData).files[0].name);
            };
            reader.readAsArrayBuffer(f);
        }

        //grouping with values, objects, arrays + alphabetical sorting in every group
        function sortJson(dat) {
            const k = Object.keys(dat);
            var retVal=[];
            for (var x in k) {
                 //console.log(k[x]," ",Array.isArray(dat[k[x]]) ," ",dat[k[x]] instanceof Object);
            	 if (!Array.isArray(dat[k[x]]) && !(dat[k[x]] instanceof Object)) retVal.push(k[x]);
            }
            retVal= retVal.sort();
            var k2=[];
            for (var x in k) {
            	 if (!Array.isArray(dat[k[x]]) && (dat[k[x]] instanceof Object)) k2.push(k[x]); //{
            }
            k2=k2.sort();
            retVal = retVal.concat(k2);
            k2=[];
            for (var x in k) {
            	 if (Array.isArray(dat[k[x]]) && (dat[k[x]] instanceof Object)) k2.push(k[x]); //[
            }
            k2=k2.sort();
            retVal = retVal.concat(k2);
            //console.log("len ",k.length," ",retVal.length);
            return retVal.reduce(
                (newObj, key) => {
                    if (Array.isArray(dat[key])) {
                        newObj[key] = [];
                        dat[key].sort();
                        for (var x in dat[key]) {
                            newObj[key].push(dat[key][x]);
                        }
                    } else if (dat[key] instanceof Object) {
                        newObj[key] = sortJson(dat[key]);
                    } else {
                        newObj[key] = dat[key];
                    }
                    return newObj;
                }, {});
        }

        //find (canCreate = false) or find+create path (canCreate = true) in output json
        //example of paths:
        //1. array[] - we don't have index number in brackets and we have
        //to create new array element (when returnWholeArray = false) or return
        //array (when returnWholeArray = true)
        //2. array[1] - we get second array element
        //3. field1.field2.field3 - all elements are separated with dots
        //4. array[1].field1
        function findOutputObject(pathInOutputData, canCreate, returnWholeArray) {
            if (debug) console.log("findOutputPath start " + pathInOutputData);
            var obj = outputData;
            var pathObj = pathInOutputData.split(".");
            var retVal = {};
            retVal.path = pathObj.join(".");
            retVal.isNewValue = false;
            for (var i = 0; i < pathObj.length; i++) {
                if (debug) console.log("element " + pathObj[i]);
                //array?
                if (pathObj[i].includes("[")) {
                    var info = pathObj[i].split(/[\[,\]]/);
                    if (obj[info[0]] == null) {
                        if (!canCreate) return retVal;
                        obj[info[0]] = [];
                        retVal.isNewValue = true;
                        if (debug) console.log("creating array");
                    }
                    //we don't have index
                    if (info[1] == "") {
                        if (returnWholeArray) {
                            retVal.obj = obj;
                            retVal.lastPathElement = info[0];
                            console.log("array return");
                            console.log(retVal);
                            return retVal;
                        }
                        //we create new one
                        obj = obj[info[0]];
                        retVal.obj = obj;
                        if (!canCreate) return retVal;
                        obj.push({});
                        retVal.isNewValue = true;
                        pathObj[i] = info[0] + "[" + (obj.length - 1) + "]";
                        if (i == pathObj.length - 1) break;
                        obj = obj[obj.length - 1];
                    } else { //we have concrete index
                        if (i == pathObj.length - 1) break;
                        if (obj[info[0]][info[1]] == null) { //no value with this index
                            if (!canCreate) return retVal;
                            obj = obj[info[0]];
                            obj.push({});
                            retVal.isNewValue = true;
                            if (Number(info[1]) == obj.length - 1) {
                                obj = obj[info[1]];
                            }
                        } else { //return concrete index
                            obj = obj[info[0]][info[1]];
                        }
                    }
                } else { //no array
                    if (obj[pathObj[i]] == null) {
                        if (!canCreate) return retVal;
                        retVal.isNewValue = true;
                        obj[pathObj[i]] = i != pathObj.length - 1 ? {} : "";
                    }
                    if (i == pathObj.length - 1) break;
                    obj = obj[pathObj[i]];
                }
            }
            retVal.obj = obj;
            retVal.lastPathElement = pathObj[pathObj.length - 1];
            retVal.path = pathObj.join(".");
            if (debug) console.log(retVal);
            return retVal;
        }

        //find value in output JSON (if exists) or set it to value
        function getPathValueToCheck(outputDataParentPath, pathInOutputData, value, addReplace, returnWholeArray) {
            var valueToCheck = value != null && Array.isArray(value) ? JSON.parse(JSON.stringify(value)) : value;
            const pathList = pathInOutputData.split(",");
            for (var p in pathList) {
                var obj = findOutputObject(getAddReplace(outputDataParentPath, pathList[p], addReplace),
                    value != null, returnWholeArray);
                if (debug) console.log(obj);
                if (obj.isNewValue) {
                    if (value != null) obj.obj[obj.lastPathElement] = value;
                } else if (obj.obj != null) {
                    valueToCheck = obj.obj[obj.lastPathElement];
                }
                pathList[p] = obj.path;
            }
            var retVal = {};
            retVal.path = pathList.join(",");
            retVal.value = valueToCheck;
            return retVal;
        }

        //find path in output JSON after all possible path replacements
        function getAddReplace(outputDataParentPath, pathInOutputData, addReplace) {
            if (debug) {
                console.log("getAddReplace start '" + outputDataParentPath + "' '" + pathInOutputData + "'");
                console.log(addReplace);
            }
            var pathList = pathInOutputData.split(",");
            for (var p in pathList) {
                if (pathList[p].startsWith("$.")) {
                    pathList[p] = pathList[p].substring(2);
                } else {
                    pathList[p] = outputDataParentPath + pathList[p];
                }
                for (var a in addReplace) {
                    pathList[p] = pathList[p].replace(a, addReplace[a]);
                }
            }
            if (debug) console.log("getAddReplace end '" + outputDataParentPath + "' '" +
                pathInOutputData + "' -> " + pathList.join(","));
            return pathList.join(",");
        }

        //example: e[1](2).e[2].e[3] gives e[1](2)
        //e[1](2).e[2](4).e[3] gives e[1](2)(4)
        function getReplaceNameFromPathInInputData(pathInInputData) {
            var retVal = "";
            const x = pathInInputData.split(".");
            for (var s in x) {
                const pathObj3 = x[s].split(/[\(,\)]/);
                if (pathObj3.length > 1) retVal += "(" + pathObj3[1] + ")";
            }
            const pathObj2 = x[0].split(/[\[,\]]/);
            return pathObj2[0] + "[" + pathObj2[1] + "]" + retVal;
        }

        //show JSON in window
        function showFormattedOutputJson() {
            document.getElementById("json").innerHTML = JSON.stringify(sortJson(outputData), null, 2);
        }

        //generate error info for some fields
        function parseEditErrors(inputDataSection, inputDataElement, value) {
            var retVal = "";
            const obj = inputData[inputDataSection][inputDataElement];
            if (obj[0] == "string") {
                if (obj[6] != "" && value != null && !value.match(new RegExp("^" + obj[6] + "$"))) {
                    retVal += "<font color=red>Text doesn't match regular exp. " + obj[6] + "</font>";
                }
                if (obj[4] != 0 || obj[5] != 0) {
                    if (value.length < Number(obj[4])) {
                        retVal += "<font color=red>Minimal length " + obj[4] + "</font>";
                    }
                    if (value.length > Number(obj[5])) {
                        retVal += "<font color=red>Maximal length " + obj[5] + "</font>";
                    }
                }
            } else if (obj[0] == "number" && (obj[4] != 0 || obj[5] != 0)) {
                if (Number(value) < Number(obj[4])) {
                    retVal += "<font color=red>Minimal value " + obj[4] + "</font>";
                }
                if (Number(value) > Number(obj[5])) {
                    retVal += "<font color=red>Maximal value " + obj[5] + "</font>";
                }
            } else if (obj[0] == "multi" && (obj[3] != 0 || obj[4] != 0)) {
                if (value.length < Number(obj[3])) {
                    retVal += "<font color=red>Select at least " + obj[3] + " values</font>";
                }
                if (value.length > Number(obj[4])) {
                    retVal += "<font color=red>Select maximally " + obj[4] + " values</font>";
                }
            }
            return retVal;
        }

        function setEditErrors(pathInOutputData, value, inputDataSection, inputDataElement) {
            document.getElementById(pathInOutputData + "_error").innerHTML =
                parseEditErrors(inputDataSection, inputDataElement, value);
        }

        function setEditErrorsMulti(pathInOutputData, values, inputDataSection, inputDataElement) {
            var val = [];
            for (var i = 0; i < values.length; i++) {
                if (values[i].selected) val.push(values[i].value);
            }
            document.getElementById(pathInOutputData + "_error").innerHTML =
                parseEditErrors(inputDataSection, inputDataElement, val);
        }

        //when we have arrayindex to array
        function updateTooltip(id, value) {
            const obj = document.getElementById(id);
            var pathObj = obj.attributes["name"]["nodeValue"].split(",");
            const info = pathObj[pathObj.length - 1].split(/[\[,\]]/);
            pathObj[pathObj.length - 1] = info[0] + "[" + value + "]";
            const obj2 = findOutputObject(pathObj.join("."), false, false);
            obj.title = obj2.obj && obj2.obj[info[0]] && obj2.obj[info[0]][value] ?
                JSON.stringify(obj2.obj[info[0]][value]) : "";
        }

        //changing one value after changing string, boolean, number, etc.
        function editStringBoolNum(pathInOutputData, value, isThisNum, canCreate) {
            if (debug) {
                console.log("editStringBoolNum");
                console.log(value);
            }
            const pathList = pathInOutputData.split(",");
            for (var p in pathList) {
                var obj = findOutputObject(pathList[p], canCreate, Array.isArray(value));
                if (obj && obj.obj && obj.lastPathElement) {
                    obj.obj[obj.lastPathElement] = isThisNum ? Number(value) : value;
                }
            }
            showFormattedOutputJson();
        }

        //after selecting smth in multiselect
        function editMulti(pathInOutputData, values) {
            var val = [];
            for (var i = 0; i < values.length; i++) {
                if (values[i].selected) val.push(values[i].value);
            }
            editStringBoolNum(pathInOutputData, val, false, true);
        }

        //called after selecting value in select
        function editSelect(pathInInputData, value, outputDataParentPath) {
            if (debug) {
                console.log("editSelect '" + pathInInputData + "' '" + value + "'");
                console.log(selectAddReplace);
            }
            const pathObj = pathInInputData.split(".");
            const info = pathObj[pathObj.length - 1].split(/[\[,\]]/);
            const elementToProcess = inputData[info[0]][info[1]];
            if (debug) console.log(elementToProcess);
            for (var j = 3; j < elementToProcess.length; j += 2) {
                if (elementToProcess[j] == value) {
                    var retVal = "";
                    const sectionObj = elementToProcess[j + 1].split(".");
                    for (s in sectionObj) {
                        retVal += processEditorPart(sectionObj[s], pathInInputData, outputDataParentPath);
                    }
                    document.getElementById(pathInInputData + "_span").innerHTML = retVal;
                    processExtraArrayElements();
                    processAllRelatedIndexes();
                    showFormattedOutputJson();
                    break;
                }
            }
            if (debug) {
                console.log("editSelect end '" + pathInInputData + "' '" + value + "'");
                console.log(selectAddReplace);
            }
        }

        //todo delete elements outside (with $.)
        function deleteArrayElement(pathInOutputData) {
            if (debug) console.log("Delete array alement " + pathInOutputData);
            var obj = findOutputObject(pathInOutputData, false, false);
            var info = obj.lastPathElement.split(/[\[,\]]/);
            if (debug) {
                console.log("selectAddReplace before deleting");
                console.log(selectAddReplace);
            }
            var pathObj = pathInOutputData.split(".");
            pathObj[pathObj.length - 1] = info[0];
            for (var jj in selectAddReplace) {
                obj2 = selectAddReplace[jj];
                for (var jjj in obj2) {
                    if (obj2[jjj].startsWith(pathObj.join(".") + "[")) {
                        pathObj2 = obj2[jjj].split(".");
                        var info2 = pathObj2[pathObj2.length - 1].split(/[\[,\]]/);
                        if (Number(info2[1]) > Number(info[1])) {
                            pathObj2[pathObj2.length - 1] = info2[0] + "[" + (Number(info2[1]) - 1) + "]";
                            obj2[jjj] = pathObj2.join(".");
                            if (debug) {
                                console.log("updating " + jjj);
                                console.log(obj2[jjj]);
                            }
                        } else if (Number(info2[1]) == Number(info[1])) {
                            if (debug) {
                                console.log("deleting " + jjj);
                                console.log(obj2);
                            }
                            delete obj2[jjj];
                        }
                    }
                }
                if (Object.keys(obj2).length == 0) delete selectAddReplace[jj];
            }
            if (debug) {
                console.log("selectAddReplace after deleting part 2");
                console.log(selectAddReplace);
            }
            //remove from json
            obj.obj[info[0]].splice(info[1], 1);
            //remove from editor
            if (document.getElementById(pathInOutputData) != null) {
                document.getElementById(pathInOutputData).remove();
            }
            //change id for allowing searching all elements
            obj0 = [document.getElementsByTagName("input"),
                document.getElementsByTagName("select"),
                document.getElementsByTagName("span"),
                document.getElementsByTagName("button")
            ];
            for (var jj in obj0) {
                obj = obj0[jj];
                for (var j in obj) {
                    //remove value from select with array index
                    if (obj[j].attributes && obj[j].attributes["name"]) {
                        if (obj[j].attributes["name"]["nodeValue"] == pathObj.join(".") + "[]") {
                            if (debug) console.log(obj[j]);
                            //remove highest value
                            toDelete = -1;
                            toDeleteValue = 0;
                            for (var jjj = 0; jjj < obj[j].length; jjj++) {
                                if (Number(obj[j][jjj].value) >= toDeleteValue) {
                                    toDelete = jjj;
                                    toDeleteValue = Number(obj[j][jjj].value);
                                }
                            }
                            obj[j].remove(toDelete);
                            editStringBoolNum(obj[j].id, obj[j].value, true, true);
                            if (obj[j].length == 0) {
                                editStringBoolNum(obj[j].id, "", false, true);
                                document.getElementById(obj[j].id + "_error")
                                    .innerHTML = "<font color=red>Needs some value</font>";
                            }
                        }
                    }
                    //update indexes of existing elements in the array
                    if (obj[j].id != null && obj[j].id.startsWith(pathObj.join("."))) {
                        pathObj2 = obj[j].id.split(".");
                        var info2 = pathObj2[pathObj.length - 1].split(/[\[,\]]/);
                        if (Number(info2[1]) > Number(info[1])) {
                            var i = Number(info2[1]);
                            pathObj2[pathObj.length - 1] = info2[0] + "[" + (i - 1) + "]";
                            obj[j].id = pathObj2.join(".");
                            //update json value for array indexes
                            if (obj[j].attributes && obj[j].attributes["name"] &&
                                obj[j].attributes["name"]["nodeValue"] == "arrayindex") {
                                var obj2 = findOutputObject(pathObj2.join("."), false, false);
                                if (obj2 && obj2.obj) {
                                    obj2.obj[obj2.lastPathElement] = Number(i - 1);
                                }
                            }
                        }
                    }
                }
            }
            showFormattedOutputJson();
            if (debug) {
                console.log("selectAddReplace after deleting");
                console.log(selectAddReplace);
            }
        }

        function deleteArrayStruct(pathInInputDataWithIndex, outputDataParentPath) {
            const x = pathInInputDataWithIndex.split(".");
            const pathObj = x[x.length - 1].split(/[\[,\]]/);
            const elementToProcess = inputData[pathObj[0]][pathObj[1]];
            const sectionObj = elementToProcess[2].split(".");
            for (s in sectionObj) {
                processEditorPart(sectionObj[s],
                    pathInInputDataWithIndex, outputDataParentPath);
            }
            document.getElementById(outputDataParentPath + pathInInputDataWithIndex).remove();
            showFormattedOutputJson();
        }

        //close/open expandable sections
        function openClose(ID) {
            if (document.getElementById(ID + '.z').style.display == 'none') {
                document.getElementById(ID + '.z').style.display = 'grid';
                document.getElementById(ID + '.y').innerHTML = '&nbsp;[-]';
            } else {
                document.getElementById(ID + '.z').style.display = 'none';
                document.getElementById(ID + '.y').innerHTML = '&nbsp;[+]';
            }
        }

        function addArrayStruct(outputDataParentPath, pathInInputData, nonDefault) {
            if (debug) {
                console.log("addArrayStruct '" + pathInInputData + "'");
                console.log(selectAddReplace);
            }
            const x = pathInInputData.split(".");
            const pathObj = x[x.length - 1].split(/[\[,\]]/);
            const elementToProcess = inputData[pathObj[0]][pathObj[1]];
            if (debug) console.log(elementToProcess);
            var elementIndex = 0;
            for (var i = 3; i < elementToProcess.length; i += 2) {
                if (elementToProcess[i + 1] == nonDefault &&
                    document.getElementById(pathInInputData + "(" + i + ").x") == null) {
                    elementIndex = i;
                    break;
                }
            }
            if (elementIndex == 0) {
                alert('Not possible. Maximal ' + ((elementToProcess.length - 3) / 2) +
                    ' elements in element ' + pathInInputData);
            } else {
                const newID = pathInInputData + "(" + elementIndex + ")";

                //first create new menu section
                var newSpanSpan = document.createElement('span');
                newSpanSpan.innerHTML = "&nbsp;[-]";
                newSpanSpan.id = newID + ".y";
                newSpanSpan.style = 'text-align:right;cursor:pointer;';
                newSpanSpan.addEventListener('click', function(event) {
                    openClose(this.id.slice(0, -2));
                });

                var newLabel = document.createElement('label');
                newLabel.innerHTML = "<b>" + elementToProcess[1] + "</b>";

                var newSpan = document.createElement('span');
                newSpan.classList.add("full");
                newSpan.innerHTML = "<br>&nbsp;<br>";
                newSpan.id = newID;

                //now create delete button and span for menu
                if (nonDefault) {
                    var newDelButton = document.createElement('button');
                    newDelButton.id = newID + ".x";
                    newDelButton.setAttribute("name", outputDataParentPath);
                    newDelButton.addEventListener('click', function(event) {
                        if (confirm("Continue?")) {
                            deleteArrayStruct(this.id.slice(0, -2), this.attributes["name"]["nodeValue"]);
                        }
                    });
                    newDelButton.innerText = "Delete";
                }

                var newInternSpan = document.createElement('span');
                newInternSpan.classList.add("full");
                newInternSpan.style = "display: grid; grid-template-columns: 1fr 1fr;";
                newInternSpan.id = newID + ".z";
                var retVal = "";
                const sectionObj = elementToProcess[elementIndex].split(".");
                for (s in sectionObj) {
                    retVal += processEditorPart(sectionObj[s], newID, outputDataParentPath);
                }
                newInternSpan.innerHTML = retVal;

                if (nonDefault) newInternSpan.appendChild(newDelButton);
                newSpan.appendChild(newLabel);
                newSpan.appendChild(newSpanSpan);
                newSpan.appendChild(newInternSpan);
                document.getElementById(pathInInputData).appendChild(newSpan);

                processAllRelatedIndexes();
                showFormattedOutputJson();
            }
            if (debug) {
                console.log("selectAddReplace after select");
                console.log(selectAddReplace);
            }
        }

        //add default sections from "adddelete" elements
        function processExtraArrayElements() {
            processing = "processExtraArrayElements";
            for (var z in addArray) {
                addArrayStruct(addArray[z].parentPathInJson, addArray[z].editorPath, false);
            }
            addArray = [];
        }

        //add new value into all related indexes
        function processAllRelatedIndexes() {
            processing = "processAllRelatedIndexes";
            const obj = document.getElementsByTagName("select");
            for (var z in obj) {
                if (obj[z].attributes && obj[z].attributes["name"]) {
                    if (debug) console.log("searching for " + obj[z].attributes["name"]["nodeValue"] + " for the end");
                    const obj2 = findOutputObject(obj[z].attributes["name"]["nodeValue"], false, false);
                    if (debug) console.log(obj2);
                    if (obj2 != null && obj2.obj != null) {
                        for (j = 0; j < obj2.obj.length; j++) {
                            var found = false;
                            for (jj = 0; jj < obj[z].options.length; jj++) {
                                if (obj[z].options[jj].value == j) {
                                    found = true;
                                    break;
                                }
                            }
                            if (!found) {
                                var op = document.createElement('option');
                                op.value = j;
                                op.innerHTML = j;
                                if (obj[z].value == "") {
                                    obj[z].add(op);
                                    editStringBoolNum(obj[z].id, j, true, true);
                                    if (debug) {
                                        console.log("before add element in option");
                                        console.log(obj2);
                                    }
                                    //obj[z].title = JSON.stringify(obj2.obj);
                                } else {
                                    obj[z].add(op);
                                }
                            }
                        }
                    }
                    if (document.getElementById(obj[z].id + "_error") != null) {
                        document.getElementById(obj[z].id + "_error").innerHTML =
                            obj[z].options.length == 0 ? "<font color=red>Needs some value</font>" : "";
                    }
                }
            }
        }

        function processEditorPart(inputDataSectionPathToProcess, inputDataParentPath, outputDataParentPath) {
            processing = "processEditorPart '" + inputDataSectionPathToProcess + "' '" +
                inputDataParentPath + "' '" + outputDataParentPath + "'";
            if (debug) {
                console.log(processing);
            }
            var editorText = "";
            const replaceName = inputDataParentPath == "" ?
                "" : getReplaceNameFromPathInInputData(inputDataParentPath);
            var addReplace = JSON.parse(JSON.stringify(
                inputDataParentPath == "" ? {} :
                (selectAddReplace[replaceName] == null ? {} : selectAddReplace[replaceName])));
            if (debug) {
                console.log("addReplace");
                console.log(addReplace);
            }
            const sectionList = inputDataSectionPathToProcess.split(",");
            for (var s in sectionList) {
                const sectionName = sectionList[s];
                const elementsToProcess = inputData[sectionName];
                for (var i in elementsToProcess) {
                    if (debug) console.log(elementsToProcess[i]);
                    const elementToProcessName = inputDataParentPath +
                        (inputDataParentPath == "" ? "" : ".") +
                        sectionName + "[" + i + "]";
                    processing = elementToProcessName + " " + JSON.stringify(elementsToProcess[i]);
                    if (debug) {
                        console.log(processing);
                    }
                    if (elementsToProcess[i][0] == "select") {
                        //option menu. Can do something extra during changing to concrete value.
                        //0 type, 1 description, 2 default, (3 name, 4 section for processing)...
                        editorText += "<span class=full>";
                        editorText += "<label>" + elementsToProcess[i][1] + "</label>";
                        editorText += "<select name='" + elementToProcessName + "'";
                        editorText += " id='" + elementToProcessName + "'";
                        editorText += " title='Default " + elementsToProcess[i][2] + "'";
                        editorText += " onchange=editSelect(this.id,this.value,'" + outputDataParentPath + "');>";
                        for (var j = 3; j < elementsToProcess[i].length; j = j + 2) {
                            editorText += "<option value='" + elementsToProcess[i][j] + "'";
                            if (elementsToProcess[i][2] == elementsToProcess[i][j]) editorText += " selected";
                            editorText += ">" + elementsToProcess[i][j] + "</option>";
                        }
                        editorText += "</select>";
                        editorText += "<span id='" + elementToProcessName + "_span' class=full>";
                        for (var j = 3; j < elementsToProcess[i].length; j += 2) {
                            if (elementsToProcess[i][2] == elementsToProcess[i][j]) {
                                editorText += processEditorPart(elementsToProcess[i][j + 1],
                                    elementToProcessName, outputDataParentPath);
                            }
                        }
                        editorText += "</span>";
                        editorText += "</span>";
                    } else if (elementsToProcess[i][0] == "adddelete") {
                        //array with adding/removing elements
                        //0 type, 1 description, 2 section delete,
                        //(3 section add, 4 section can delete)...
                        editorText += "<span class=full>";
                        editorText += "<label>" + elementsToProcess[i][1] + "</label>";
                        editorText += "<input type=button value='Add'";
                        editorText += " name='" + elementToProcessName + "'";
                        editorText += " onclick=addArrayStruct('" + outputDataParentPath + "'," +
                            "'" + elementToProcessName + "',true);>";
                        editorText += "<span id='" + elementToProcessName + "' class=full></span>";
                        //add sections, which cannot be later deleted
                        for (var j = 3; j < elementsToProcess[i].length; j += 2) {
                            if (elementsToProcess[i][j + 1] == false) {
                                var ret = {};
                                ret.editorPath = elementToProcessName;
                                ret.parentPathInJson = outputDataParentPath;
                                addArray.push(ret);
                            }
                        }
                        editorText += "</span>";
                    } else if (elementsToProcess[i][0] == "link") {
                        //link to existing structure
                        //0 type, 1 path, 2 section, (optional 3 title string for +- section)                        
                        if (elementsToProcess[i].length == 4) {
                            editorText += "<span class=full><br>&nbsp;<br>";
                            editorText += "<label><b>" + elementsToProcess[i][3] + "</b></label>";
                            editorText += "<span id='" + elementToProcessName + ".y' style='text-align:right;cursor:pointer;'";
                            editorText += " onclick='openClose(this.id.slice(0, -2));'>&nbsp;[-]</span>";
                            editorText += "<span id='" + elementToProcessName + ".z' class=full";
                            editorText += " style='display: grid; grid-template-columns: 1fr 1fr;'>";
                        }
                        if (elementsToProcess[i][1] != "") {
                            const obj = findOutputObject(getAddReplace(outputDataParentPath,
                                elementsToProcess[i][1], addReplace), true, false);
                            editorText += processEditorPart(elementsToProcess[i][2],
                                elementToProcessName, obj.path + ".");
                        } else {
                            editorText += processEditorPart(elementsToProcess[i][2],
                                elementToProcessName, "");
                        }
                        if (elementsToProcess[i].length == 4) {
                            editorText += "</span>";
                            editorText += "</span>";
                        }
                    } else if (elementsToProcess[i][0] == "index") {
                        //field with index of existing "other array": 0 type, 1 field inside "other array"
                        if (elementsToProcess[i].length == 2) {
                            const obj = findOutputObject(getAddReplace(outputDataParentPath,
                                elementsToProcess[i][1], addReplace), true, false);
                            const info = obj.path.split(".");
                            const info2 = info[info.length - 2].split(/[\[,\]]/);
                            obj.obj[obj.lastPathElement] = Number(info2[1]);
                            var x = obj.path.split(".");
                            x = x.pop();
                            editorText += "<span name=arrayindex id='" +
                                (Array.isArray(x) ? x.join(".") : x) + "'></span>";
                        } else if (elementsToProcess[i].length == 3) {
                            //field with index of existing "other array": 0 type, 1 field path,
                            //2 "other array" path
                            const obj = findOutputObject(getAddReplace(outputDataParentPath,
                                elementsToProcess[i][1], addReplace), true, false);
                            const obj2 = findOutputObject(getAddReplace(outputDataParentPath,
                                elementsToProcess[i][2], addReplace), true, false);
                            if (debug) {
                                console.log("new index");
                                console.log(obj);
                                console.log(obj2);
                                console.log(addReplace);
                            }
                            const info = obj2.lastPathElement.split(/[\[,\]]/);
                            obj.obj[obj.lastPathElement] = Number(info[1]);
                            editorText += "<span name=arrayindex2 id='" + obj.path + "'></span>"; //fixme
                        } else {
                            //field with "other array" index (for selecting): 
                            //0 type, 1 path, 2 description, 3 "other array" path
                            const obj = findOutputObject(
                                getAddReplace(outputDataParentPath,
                                    elementsToProcess[i][1], addReplace), true, false);
                            editorText += "<span class=full>";
                            editorText += "<label>" + elementsToProcess[i][2] + "</label>";
                            editorText += "<select name='" + elementsToProcess[i][3] + "'";
                            editorText += " id='" + obj.path + "'";
                            //values in title can be not always actual in developer tools
                            editorText += " oninput=editStringBoolNum(this.id,this.value,true,true);";
                            editorText += " onmouseover=updateTooltip(this.id,this.value);>";
                            editorText += "</select>";
                            editorText += "<span id='" + obj.path + "_error'>";
                            editorText += "</span>";
                            editorText += "</span>";
                        }
                    } else if (elementsToProcess[i][0] == "delete") {
                        //deleting smth from json
                        //0 type, 1 path
                        if (debug) {
                            console.log(addReplace);
                            console.log(selectAddReplace);
                        }
                        const pathList = elementsToProcess[i][1].split(",");
                        for (var p in pathList) {
                            if (debug) {
                                console.log("delete with");
                                console.log(pathList);
                                console.log(pathList[p]);
                            }
                            var obj = findOutputObject(getAddReplace(outputDataParentPath,
                                pathList[p], addReplace), false, false);
                            if (obj.obj != null && obj.lastPathElement != null) {
                                if (obj.lastPathElement.includes("[")) {
                                    deleteArrayElement(obj.path);
                                } else {
                                    if (debug) console.log("deleting " + obj.lastPathElement);
                                    delete obj.obj[obj.lastPathElement];
                                    if (debug) console.log(obj.obj);
                                }
                            }
                        }
                    } else if (elementsToProcess[i][0] == "const") {
                        //0 type, 1 path, 2 value, (optional 3 true set only when exists)
                        const pathList = elementsToProcess[i][1].split(",");
                        for (var p in pathList) {
                            var obj = findOutputObject(getAddReplace(outputDataParentPath, pathList[p], addReplace),
                                true, false);
                            if (obj.isNewValue ||
                                (!obj.isNewValue && elementsToProcess[i].length == 3 && elementsToProcess[i][2] == true)) {
                                obj.obj[obj.lastPathElement] = elementsToProcess[i][2];
                            }
                        }
                    } else if (elementsToProcess[i][0] == "random") {
                        //put into json random value. When you put this is before string,
                        //it can replace default value from string (only when it didn't exist in json)
                        //0 type, 1 path, 2 allowed chars, 3 length, 4 string before, 5 string after
                        var s = "";
                        for (var j = 0; j < Number(elementsToProcess[i][3]); j++) {
                            s += elementsToProcess[i][2].charAt(Math.random() * elementsToProcess[i][2].length);
                        }
                        getPathValueToCheck(outputDataParentPath, elementsToProcess[i][1],
                            elementsToProcess[i][4] + s + elementsToProcess[i][5], addReplace, false);
                    } else if (elementsToProcess[i][0] == "separator") {
                        //just menu section written in bold. alternative: link with extra string param in the end
                        //0 type, 1 text
                        editorText += "<span class=full><br>&nbsp;<br>";
                        editorText += "<label><b>" + elementsToProcess[i][1] + "</b></label>";
                        editorText += "</span>";
                    } else if (elementsToProcess[i][0] == "addreplace") {
                        //replace some path elements (defined for example with name) with other
                        //can be used to generating new element in array and
                        //redirecting generated index to all futher menu options
                        //0 type, 1 path, 2 (optional) name
                        const pathList = elementsToProcess[i][1].split(",");
                        for (p in pathList) {
                            obj = findOutputObject(outputDataParentPath + pathList[p], true, false);
                            addReplace[elementsToProcess[i].length == 3 ?
                                elementsToProcess[i][2] :
                                getAddReplace(outputDataParentPath, pathList[p], addReplace)] = obj.path;
                        }
                        if (debug) {
                            console.log("addReplace");
                            console.log(addReplace);
                        }
                        selectAddReplace[replaceName] = JSON.parse(JSON.stringify(addReplace));
                    } else if (elementsToProcess[i][0] == "string") {
                        //string parameter
                        //0 type, 1 path, 2 description, 3 default, 4 minimum len, 5 maximum len, 
                        //6 empty or parsing regexp
                        const pathValue = getPathValueToCheck(outputDataParentPath,
                            elementsToProcess[i][1], elementsToProcess[i][3], addReplace, false);
                        editorText += "<span class=full>";
                        editorText += "<label>" + elementsToProcess[i][2] + "</label>";
                        editorText += "<input";
                        if (pathValue.value != null) editorText += " value='" + pathValue.value + "'";
                        editorText += " id='" + pathValue.path + "'";
                        editorText += " name='" + elementToProcessName + "'";
                        var title = "";
                        if (elementsToProcess[i][4] != elementsToProcess[i][5]) {
                            editorText += " minlength=" + elementsToProcess[i][4];
                            editorText += " maxlength=" + elementsToProcess[i][5];
                            title += "Minimum length " + elementsToProcess[i][4];
                            title += ", maximum length " + elementsToProcess[i][5];
                        } else {
                            title += "No minimum and maximum length";
                        }
                        title += ", default \"" + pathValue.value + "\"";
                        editorText += " title='" + title + "'";
                        editorText += " oninput=editStringBoolNum(this.id,this.value,false,true);setEditErrors(this.id,this.value,'" +
                            sectionName + "','" + i + "');><br>";
                        editorText += "<span id='" + pathValue.path + "_error'>";
                        editorText += parseEditErrors(sectionName, i, pathValue.value);
                        editorText += "</span>";
                        editorText += "</span>";
                    } else if (elementsToProcess[i][0] == "number") {
                        //number parameter
                        //0 type, 1 path, 2 description, 3 default, 4 minimum, 5 maximum, 6 zero or step, 
                        //7 (optional) don't create elements
                        const pathValue = getPathValueToCheck(outputDataParentPath,
                            elementsToProcess[i][1], elementsToProcess[i][3], addReplace, false);
                        editorText += "<span class=full>";
                        editorText += "<label>" + elementsToProcess[i][2] + "</label>";
                        editorText += "<input";
                        editorText += " type=number id='" + pathValue.path + "'";
                        editorText += " name='" + elementToProcessName + "'";
                        var title = "";
                        if (elementsToProcess[i][4] != elementsToProcess[i][5]) {
                            editorText += " min=" + elementsToProcess[i][4];
                            editorText += " max=" + elementsToProcess[i][5];
                            title += "Minimum " + elementsToProcess[i][4];
                            title += ", maximum " + elementsToProcess[i][5];
                        } else {
                            title += "No minimum and maximum";
                        }
                        if (Number(elementsToProcess[i][6]) != 0) {
                            editorText += " step=" + elementsToProcess[i][6];
                            title += ", step " + elementsToProcess[i][6];
                        }
                        if (pathValue.value != null) {
                            editorText += " value=" + pathValue.value;
                            title += ", default " + pathValue.value;
                        }
                        editorText += " title='" + title + "'";
                        editorText += " oninput=editStringBoolNum(this.id,this.value,true,";
                        editorText += !(elementsToProcess[i].length == 8) + ");setEditErrors(this.id,this.value,'" +
                            sectionName + "','" + i + "');><br>";
                        editorText += "<span id='" + pathValue.path + "_error'>";
                        editorText += parseEditErrors(sectionName, i, pathValue.value);
                        editorText += "</span>";
                        editorText += "</span>";
                    } else if (elementsToProcess[i][0] == "date" || elementsToProcess[i][0] == "time") {
                        //date or time parameter
                        //0 type, 1 path, 2 description, 3 default (today or now, when empty), 4 minimum, 5 maximum
                        const date = new Date();
                        const defVal = elementsToProcess[i][0] == "date" ?
                            date.getFullYear() + "-" +
                            (date.getMonth() + 1 < 10 ? "0" : "") + (date.getMonth() + 1) + "-" +
                            (date.getDate() < 10 ? "0" : "") + date.getDate() :
                            (date.getHours() < 10 ? "0" : "") + date.getHours() + ":" +
                            (date.getMinutes() < 10 ? "0" : "") + date.getMinutes() + ":" +
                            (date.getSeconds() < 10 ? "0" : "") + date.getSeconds();
                        const pathValue = getPathValueToCheck(outputDataParentPath, elementsToProcess[i][1],
                            elementsToProcess[i][3] == "" ? defVal : elementsToProcess[i][3], addReplace, false);
                        editorText += "<span class=full>";
                        editorText += "<label>" + elementsToProcess[i][2] + "</label>";
                        editorText += "<input value='" + pathValue.value + "' ";
                        editorText += " name='" + elementToProcessName + "'";
                        var title = "";
                        if (elementsToProcess[i][4] != elementsToProcess[i][5]) {
                            editorText += " min=" + elementsToProcess[i][4];
                            editorText += " max=" + elementsToProcess[i][5];
                            title += "Minimum " + elementsToProcess[i][4];
                            title += ", maximum " + elementsToProcess[i][5];
                        } else {
                            title += "No minimum and maximum";
                        }
                        title += ", default " + pathValue.value;
                        editorText += " title='" + title + "'";
                        editorText += " id='" + pathValue.path + "'";
                        editorText += " type=" + elementsToProcess[i][0];
                        editorText += " oninput=editStringBoolNum(this.id,this.value,false,true);><br>";
                        editorText += "</span>";
                    } else if (elementsToProcess[i][0] == "checkbox" || elementsToProcess[i][0] == "checkfalse") {
                        //real true & false in json. For string use option
                        //0 type, 1 path, 2 description, 3 default
                        const pathValue = getPathValueToCheck(outputDataParentPath,
                            elementsToProcess[i][1], elementsToProcess[i][3], addReplace);
                        editorText += "<span class=full>";
                        editorText += "<label>" + elementsToProcess[i][2] + "</label>";
                        editorText += "<input type=checkbox";
                        editorText += " name='" + elementToProcessName + "'";
                        if (elementsToProcess[i][3] == (elementsToProcess[i][0] == "checkbox")) editorText += " checked";
                        editorText += " title='Default " +
                            (elementsToProcess[i][0] == "checkbox" ? elementsToProcess[i][3] : !elementsToProcess[i][3]) + "'";
                        editorText += " id='" + pathValue.path + "' oninput=editStringBoolNum(this.id," +
                            (elementsToProcess[i][0] == "checkbox" ? "" : "!") + "this.checked,false,true);><br>";
                        editorText += "</span>";
                    } else if (elementsToProcess[i][0] == "option") {
                        //select one of predefined options
                        //0 type, 1 path, 2 description, 3 default, (4 value)...
                        const pathValue = getPathValueToCheck(outputDataParentPath,
                            elementsToProcess[i][1], elementsToProcess[i][3], addReplace, false);
                        editorText += "<span class=full>";
                        editorText += "<label>" + elementsToProcess[i][2] + "</label>";
                        editorText += "<select id='" + pathValue.path + "'";
                        editorText += " name='" + elementToProcessName + "'";
                        editorText += " title='Default " + elementsToProcess[i][3] + "'";
                        editorText += " onchange=editStringBoolNum(this.id,this.value,false,true);>";
                        for (var j = 4; j < elementsToProcess[i].length; j++) {
                            editorText += "<option value='" + elementsToProcess[i][j] + "'";
                            if (elementsToProcess[i][3] == elementsToProcess[i][j]) editorText += " selected";
                            editorText += ">" + elementsToProcess[i][j] + "</option>";
                        }
                        editorText += "</select>";
                        editorText += "</span>";
                    } else if (elementsToProcess[i][0] == "multi") {
                        //select one or more predefined options
                        //0 type, 1 path, 2 description, 3 minimum, 4 maximum, (5 value, 6 selected)...
                        var def = [];
                        for (var j = 5; j < elementsToProcess[i].length; j += 2) {
                            if (elementsToProcess[i][j + 1] == true) def.push(elementsToProcess[i][j]);
                        }
                        const pathValue = getPathValueToCheck(outputDataParentPath,
                            elementsToProcess[i][1], def, addReplace, true);
                        if (debug) console.log(pathValue);
                        editorText += "<span class=full>";
                        editorText += "<label>" + elementsToProcess[i][2] + "</label>";
                        editorText += "<select multiple id='" + pathValue.path + "'";
                        editorText += " name='" + elementToProcessName + "'";
                        var title = "Default " + JSON.stringify(def);
                        if (elementsToProcess[i][3] != 0 || elementsToProcess[i][4] != 0) {
                            title += ", minimum " + elementsToProcess[i][3] + " elements";
                            title += ", maximum " + elementsToProcess[i][4] + " elements";
                        }
                        editorText += " title='" + title + "'";
                        editorText += " oninput=editMulti(this.id,this.options);setEditErrorsMulti(this.id,this.options,'" +
                            sectionName + "','" + i + "');>";
                        for (var j = 5; j < elementsToProcess[i].length; j += 2) {
                            editorText += "<option value='" + elementsToProcess[i][j] + "'";
                            if (elementsToProcess[i][j + 1] == true) editorText += " selected";
                            editorText += ">" + elementsToProcess[i][j] + "</option>";
                        }
                        editorText += "</select>";
                        editorText += "<span id='" + pathValue.path + "_error'>";
                        editorText += parseEditErrors(sectionName, i, def);
                        editorText += "</span>";
                        editorText += "</span>";
                    } else if (elementsToProcess[i][0] == "file64" || elementsToProcess[i][0] == "fileHex") {
                        //Base64 or HexDec encoded file
                        //0 type, 1 path, 2 description, 3 default value, 
                        //4 default download name (mandatory), 5 empty or filter
                        const pathValue = getPathValueToCheck(outputDataParentPath,
                            elementsToProcess[i][1], elementsToProcess[i][3], addReplace, false);
                        editorText += "<span class=full>";
                        editorText += "<label>" + elementsToProcess[i][2] + "</label>";
                        editorText += "<a id='" + pathValue.path + "_get' href=''";
                        editorText += " title='Click to get file content from " + elementToProcessName + "'";
                        if (elementsToProcess[i][4] != "") editorText += " download='" + elementsToProcess[i][4] + "'";
                        editorText += " name='" + elementToProcessName + "'";
                        editorText += " onclick='return getOutputFile(\"" + pathValue.path + "\",";
                        editorText += (elementsToProcess[i][0] == "fileHex");
                        editorText += ");'>Get file</a>";
                        editorText += "<input type=file id='" + pathValue.path + "'";
                        if (elementsToProcess[i][5] != "") editorText += " accept='" + elementsToProcess[i][5] + "'";
                        editorText += " onchange=loadFile(this.files[0],this.id,";
                        editorText += (elementsToProcess[i][0] == "fileHex");
                        editorText += ");><br>";
                        editorText += "</span>";
                    }
                }
            }
            if (debug) {
                console.log("processEditorPart end '" + inputDataSectionPathToProcess + "' '" +
                    inputDataParentPath + "' '" + outputDataParentPath + "'");
            }
            console.log(selectAddReplace);
            return editorText;
        }

        document.getElementById("file").addEventListener("change",
            function(e) {
                const fReader = new FileReader();
                fReader.onload = function(e2) {
                    jsonTxt = e2.target.result;
                    try {
                        inputData = JSON.parse(jsonTxt);
                        if (inputData.start == null) {
                            alert("No start section in file '" + document.getElementById('file').files[0].name +
                                "'. Processing element '" + processing + "'. " +
                                "Is this really json file with json description?");
                        } else {
                            outputData = {};
                            addArray = [];
                            selectAddReplace = {};
                            document.getElementById("editor").innerHTML = processEditorPart("start", "", "");
                            processExtraArrayElements();
                            processAllRelatedIndexes();
                            showFormattedOutputJson();
                            if (debug) console.log(selectAddReplace);
                            document.title = document.getElementById('file').files[0].name +
                                " - DataCreator (MIT license) " + version;
                            const info = inputData["info"];
                            document.getElementById('info').innerHTML = "";
                            for (var s in info) {
                                if (document.getElementById('info').innerHTML != "") {
                                    document.getElementById('info').innerHTML =
                                        document.getElementById('info').innerHTML + "<br>";
                                }
                                document.getElementById('info').innerHTML =
                                    document.getElementById('info').innerHTML + info[s];
                            }
                        }
                    } catch (ee) {
                        alert("Error opening file '" + document.getElementById('file').files[0].name +
                            "'. Processing element '" + processing + "'. " +
                            "Is this really json file with json description?\n\n" + ee.name + "\n\n" + ee.message);
                    }
                };
                fReader.readAsText(e.target.files[0]);
            });
    </script>
</body>

</html>
